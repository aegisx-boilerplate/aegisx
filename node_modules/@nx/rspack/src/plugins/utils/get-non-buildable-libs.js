"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNonBuildableLibs = getNonBuildableLibs;
const get_transitive_deps_1 = require("./get-transitive-deps");
const is_lib_buildable_1 = require("./is-lib-buildable");
/**
 * Get all non-buildable libraries in the project graph for a given project.
 * This function retrieves all direct and transitive dependencies of a project,
 * filtering out only those that are libraries and not buildable.
 * @param graph Project graph
 * @param projectName The project name to get dependencies for
 * @returns A list of all non-buildable libraries that the project depends on, including transitive dependencies.
 */
function getNonBuildableLibs(graph, projectName) {
    const deps = graph?.dependencies?.[projectName] ?? [];
    const allNonBuildable = new Set();
    // First, find all direct non-buildable deps and add them App -> library
    const directNonBuildable = deps.filter((dep) => {
        const node = graph.nodes?.[dep.target];
        if (!node || node.type !== 'lib')
            return false;
        const hasBuildTarget = 'build' in (node.data?.targets ?? {});
        if (hasBuildTarget)
            return false;
        return !(0, is_lib_buildable_1.isBuildableLibrary)(node);
    });
    // Add direct non-buildable dependencies
    for (const dep of directNonBuildable) {
        const packageName = graph.nodes?.[dep.target]?.data?.metadata?.js?.packageName;
        if (packageName) {
            allNonBuildable.add(packageName);
        }
        // Get all transitive non-buildable dependencies App -> library1 -> library2
        const transitiveDeps = (0, get_transitive_deps_1.getAllTransitiveDeps)(graph, dep.target);
        transitiveDeps.forEach((pkg) => allNonBuildable.add(pkg));
    }
    return Array.from(allNonBuildable);
}
