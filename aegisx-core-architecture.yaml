project:
  name: AegisX Universal Core API
  description: >
    Enterprise-grade API boilerplate built with Fastify, TypeScript, and Event-Driven Architecture.
    Designed using a Modular Monolith Architecture with Domain-Based Modules and Nested Features,
    following a layered approach (controller, service, schema) inside each feature.
    Ensures scalability, testability, and maintainability.
    Can be used as a universal boilerplate core API for multiple systems.

  scope:
    included:
      [
        "Backend API",
        "Database layer",
        "Authentication",
        "Message Queue",
        "Caching",
        "Testing",
        "Documentation",
      ]
    excluded:
      [
        "Frontend apps",
        "Mobile apps",
        "Nx workspace frontend",
        "Client-side architecture",
      ]

  integration_points:
    frontend: "RESTful API + WebSocket, JWT auth, CORS, OpenAPI docs"
    external: "PostgreSQL, Redis, RabbitMQ, Third-party APIs"

technical_stack:
  runtime: Node.js 22 LTS
  framework: Fastify 4.x
  language: TypeScript 5.x
  database:
    primary: PostgreSQL 15+
    cache: Redis 7+
    search: Elasticsearch 8.x (optional)
  message_queue: RabbitMQ 3.12+
  testing: Vitest + Playwright + Testcontainers
  monitoring: Prometheus + Grafana + OpenTelemetry
  build_system:
    compiler: SWC (20x faster than tsc)
    type_checking: TypeScript compiler (separate from build)
    bundler: SWC with zero configuration
    dev_server: ts-node-dev for development
  validation: TypeBox schemas
  orm: Knex.js
  dependency_injection: TSyringe
  documentation: OpenAPI 3.0 + Swagger
  message_broker: RabbitMQ for event-driven architecture

architecture:
  style: "Modular Monolith"
  structure: "Domain-Based Modules → Features → Layers (Controller, Service, Repository)"
  patterns:
    [
      "Repository Pattern",
      "CQRS",
      "Event Sourcing",
      "Dependency Injection",
      "Unit of Work Pattern",
    ]
  principles: ["High Cohesion", "Loose Coupling", "Event-Driven Communication"]

folder_structure: |
  src/
  ├── shared/           # Cross-cutting concerns
  │   ├── interfaces/   # Common interfaces
  │   ├── middleware/   # Auth, validation, error handling
  │   ├── utils/        # Helpers and utilities
  │   ├── config/       # Configuration management
  │   ├── constants/    # Application constants
  │   └── types/        # Global TypeScript types
  ├── modules/          # Domain modules
  │   ├── user/         # User domain
  │   │   ├── controllers/
  │   │   ├── services/
  │   │   ├── repositories/
  │   │   ├── schemas/
  │   │   ├── interfaces/
  │   │   └── types/
  │   ├── auth/         # Authentication domain
  │   ├── role/         # Role & Permission management
  │   ├── notification/ # Notification system
  │   └── audit/        # Audit logging
  ├── database/         # DB migrations, seeds
  ├── events/           # Event handlers & publishers
  ├── jobs/             # Background job processing
  ├── plugins/          # Fastify plugins
  ├── routes/           # Route definitions
  └── app.ts           # Application entry point

core_modules:
  authentication:
    features:
      [
        "Login",
        "Register",
        "Password Reset",
        "Email Verification",
        "2FA",
        "Session Management",
      ]
    tokens: "JWT (Access + Refresh) with RS256 algorithm"
    providers: "Local, OAuth2 (Google, GitHub), LDAP support"
    security: "Rate limiting, Account lockout, Password policies"

  authorization:
    rbac: "Role-Based Access Control with hierarchical roles"
    pbac: "Permission-Based Access Control with granular permissions"
    resource_level: "Resource-specific permissions (own vs all)"
    middleware: "Route-level and method-level authorization"

  user_management:
    features:
      [
        "CRUD operations",
        "Profile management",
        "Avatar upload",
        "User preferences",
      ]
    validation: "Email uniqueness, Password strength, Input sanitization"
    events: "User created/updated/deleted events"

  audit_logging:
    tracking: "All user actions, data changes, API calls"
    retention: "Configurable retention periods"
    compliance: "GDPR, SOX, HIPAA compliance support"
    search: "Full-text search capabilities"

  notification_system:
    channels: ["Email", "SMS", "Push notifications", "In-app"]
    templates: "Dynamic template system with variables"
    scheduling: "Delayed and recurring notifications"
    preferences: "User notification preferences"

security:
  authentication:
    jwt:
      algorithm: RS256
      expiry: "15m (access), 7d (refresh)"
      issuer: aegisx-api
    api_key:
      format: "aegisx_ + base64(32_bytes)"
      rate_limit: "1000/hour per key"
  authorization:
    rbac: "Role-Based Access Control"
    pbac: "Permission-Based Access Control"
    resource_based: "Resource-level permissions"
  input_validation:
    schema: "JSON Schema validation"
    sanitization: "DOMPurify for HTML content"
    rate_limiting: "100 req/min per IP, 1000 req/min per user"
  encryption:
    passwords: "bcrypt (cost: 12)"
    sensitive_data: "AES-256-GCM"
    database: "TDE (Transparent Data Encryption)"
  headers:
    helmet: "helmet.js for security headers"
    cors: "CORS configuration"
    csp: "CSP (Content Security Policy)"
  input_sanitization: "XSS prevention, SQL injection protection"
  file_upload: "Virus scanning, File type validation, Size limits"
  api_security: "API versioning, Request signing, HTTPS enforcement"

database_design:
  tables:
    [
      "users",
      "roles",
      "permissions",
      "user_roles",
      "role_permissions",
      "events",
      "audit_logs",
      "notifications",
      "sessions",
    ]
  patterns: ["UUID primary keys", "Timestamps", "Soft deletes", "Audit trail"]
  indexes: "Strategic indexing on query patterns"
  migrations: "Version-controlled with Knex.js"
  seeds: "Test data and initial configuration"
  backup: "Automated backup strategies"
  performance: "Connection pooling, Query optimization"

  detailed_schema:
    users:
      table: users
      fields:
        - id: UUID (primary key)
        - email: VARCHAR(255) UNIQUE NOT NULL
        - password_hash: VARCHAR(255) NOT NULL
        - first_name: VARCHAR(100)
        - last_name: VARCHAR(100)
        - is_active: BOOLEAN DEFAULT true
        - email_verified: BOOLEAN DEFAULT false
        - created_at: TIMESTAMP
        - updated_at: TIMESTAMP
      indexes:
        - email (unique)
        - created_at
        - is_active

    roles:
      table: roles
      fields:
        - id: UUID (primary key)
        - name: VARCHAR(50) UNIQUE NOT NULL
        - description: TEXT
        - is_system: BOOLEAN DEFAULT false
        - created_at: TIMESTAMP
        - updated_at: TIMESTAMP

    permissions:
      table: permissions
      fields:
        - id: UUID (primary key)
        - name: VARCHAR(100) UNIQUE NOT NULL
        - resource: VARCHAR(50) NOT NULL
        - action: VARCHAR(50) NOT NULL
        - description: TEXT
        - created_at: TIMESTAMP

    events:
      table: events
      fields:
        - id: UUID (primary key)
        - event_type: VARCHAR(100) NOT NULL
        - aggregate_id: UUID
        - aggregate_type: VARCHAR(50)
        - event_data: JSONB NOT NULL
        - metadata: JSONB
        - version: INTEGER NOT NULL
        - occurred_at: TIMESTAMP NOT NULL
        - created_at: TIMESTAMP DEFAULT NOW()
      indexes:
        - aggregate_id, version
        - event_type
        - occurred_at

    audit_logs:
      table: audit_logs
      fields:
        - id: UUID (primary key)
        - user_id: UUID (FK to users.id)
        - action: VARCHAR(100) NOT NULL
        - resource_type: VARCHAR(50)
        - resource_id: UUID
        - old_values: JSONB
        - new_values: JSONB
        - ip_address: INET
        - user_agent: TEXT
        - occurred_at: TIMESTAMP NOT NULL
      indexes:
        - user_id, occurred_at
        - resource_type, resource_id
        - action
        - occurred_at

api_specifications:
  versioning: "URL path (/api/v1/, /api/v2/)"
  response_format: "Standardized JSON with success/error structure"
  error_codes: "Categorized codes (AUTH_001, VALIDATION_001, etc.)"
  pagination: "Cursor-based for large datasets"
  documentation: "OpenAPI 3.0 with Swagger UI"
  filtering: "Query parameter filtering and sorting"
  compression: "Gzip compression for responses"
  caching: "ETag and Cache-Control headers"

  detailed_specs:
    versioning:
      strategy: "URL path versioning (/api/v1/, /api/v2/)"
      current: v1
      deprecation_policy: "6 months notice"

    response_format:
      success:
        structure:
          - "success: true"
          - "data: object|array"
          - "meta: object (pagination, etc.)"
      error:
        structure:
          - "success: false"
          - "error: object"
          - "code: string"
          - "message: string"
          - "details: array (validation errors)"

    error_codes:
      authentication:
        - "AUTH_001: Invalid credentials"
        - "AUTH_002: Token expired"
        - "AUTH_003: Token invalid"
        - "AUTH_004: API key invalid"
        - "AUTH_005: Account locked"
      authorization:
        - "AUTHZ_001: Insufficient permissions"
        - "AUTHZ_002: Resource access denied"
        - "AUTHZ_003: Role not found"
        - "AUTHZ_004: Permission denied"
      validation:
        - "VAL_001: Required field missing"
        - "VAL_002: Invalid field format"
        - "VAL_003: Field value out of range"
        - "VAL_004: Duplicate value"
      system:
        - "SYS_001: Internal server error"
        - "SYS_002: Service unavailable"
        - "SYS_003: Database connection error"
        - "SYS_004: Rate limit exceeded"

    endpoints:
      authentication:
        - "POST /api/v1/auth/login"
        - "POST /api/v1/auth/logout"
        - "POST /api/v1/auth/refresh"
        - "POST /api/v1/auth/forgot-password"
        - "POST /api/v1/auth/reset-password"
      users:
        - "GET /api/v1/users (list with pagination)"
        - "GET /api/v1/users/:id"
        - "POST /api/v1/users"
        - "PUT /api/v1/users/:id"
        - "DELETE /api/v1/users/:id"
        - "GET /api/v1/users/me (current user profile)"
      roles:
        - "GET /api/v1/roles"
        - "GET /api/v1/roles/:id"
        - "POST /api/v1/roles"
        - "PUT /api/v1/roles/:id"
        - "DELETE /api/v1/roles/:id"
      permissions:
        - "GET /api/v1/permissions"
        - "GET /api/v1/permissions/:id"
        - "POST /api/v1/permissions"
        - "PUT /api/v1/permissions/:id"
        - "DELETE /api/v1/permissions/:id"
      health:
        - "GET /health (basic health check)"
        - "GET /health/detailed (detailed system status)"
        - "GET /metrics (Prometheus metrics)"

message_queue_system:
  broker: RabbitMQ
  patterns:
    [
      "Event Publishing",
      "Event Handlers",
      "Dead Letter Queues",
      "Delayed Messages",
    ]
  exchanges: ["Direct", "Topic", "Fanout"]
  use_cases: ["User events", "Audit logs", "Notifications", "Background jobs"]
  retry_logic: "Exponential backoff with maximum retry limits"
  monitoring: "Queue depth monitoring and alerting"

caching_strategy:
  layers: ["Application cache", "Database query cache", "Session cache"]
  redis_usage: "Session storage, Rate limiting, Temporary data"
  cache_patterns: ["Cache-aside", "Write-through", "Write-behind"]
  invalidation: "Event-based cache invalidation"
  performance: "Cache hit ratio monitoring"

  detailed_strategy:
    strategy:
      - Redis for session storage
      - Application-level caching for frequently accessed data
      - HTTP caching headers for static content
    ttl:
      - User sessions: 15 minutes
      - Role/Permission data: 1 hour
      - System configuration: 24 hours

background_jobs:
  processor: "Bull/BullMQ with Redis"
  job_types:
    ["Email sending", "File processing", "Data cleanup", "Report generation"]
  scheduling: "Cron-based and delayed job execution"
  monitoring: "Job status tracking and failure handling"
  scaling: "Horizontal job worker scaling"

file_management:
  storage: "Local filesystem or cloud storage (S3, GCS)"
  upload: "Multipart upload with progress tracking"
  processing: "Image resizing, Document conversion"
  security: "Virus scanning, Access control"
  cdn: "CDN integration for static assets"

logging_monitoring:
  structured_logging: "Winston with JSON format"
  log_levels: "Error, Warn, Info, Debug with environment-based filtering"
  distributed_tracing: "OpenTelemetry with Jaeger"
  metrics: "Prometheus with custom business metrics"
  alerting: "Grafana alerts on key metrics"
  apm: "Application Performance Monitoring"

testing_strategy:
  unit: "Vitest for services, repositories, utilities"
  integration: "API endpoints with test database"
  e2e: "Playwright for complete user flows"
  performance: "Load testing with autocannon"
  tools: "Testcontainers for database, MSW for external APIs"
  coverage: "80%+ code coverage requirements"
  ci_testing: "Automated testing in CI/CD pipeline"

  detailed_strategy:
    unit_tests:
      coverage: 90% minimum
      framework: Vitest
      mocking: vi.mock() for external dependencies

    integration_tests:
      database: Testcontainers for PostgreSQL
      cache: Testcontainers for Redis
      api: Supertest for HTTP testing

    e2e_tests:
      framework: Playwright
      environment: Dedicated testing environment

    performance_tests:
      load_testing: Artillery or k6
      stress_testing: Gradual load increase
      benchmarking: Regular performance benchmarks

configuration_management:
  environment_variables: "dotenv with validation"
  config_validation: "Schema-based configuration validation"
  secrets_management: "External secret stores (Vault, AWS Secrets)"
  feature_flags: "Dynamic feature toggling"
  hot_reload: "Configuration changes without restart"

error_handling:
  global_handler: "Centralized error handling middleware"
  error_types: "Custom error classes with specific handling"
  logging: "Structured error logging with context"
  user_feedback: "User-friendly error messages"
  monitoring: "Error tracking and alerting"

health_monitoring:
  health_checks: "Database, Redis, RabbitMQ connectivity"
  readiness_probes: "Service dependency checks"
  liveness_probes: "Application health status"
  metrics_endpoint: "Prometheus metrics exposure"
  status_page: "Public status page for external services"

api_gateway_features:
  rate_limiting: "Distributed rate limiting with Redis"
  request_transformation: "Input/output data transformation"
  response_caching: "Response caching at gateway level"
  load_balancing: "Round-robin and weighted routing"
  circuit_breaker: "Fault tolerance patterns"

websocket_support:
  real_time: "Socket.io integration with Fastify"
  authentication: "JWT-based WebSocket authentication"
  room_management: "User rooms and broadcasting"
  scaling: "Redis adapter for multi-instance support"
  events: "Real-time notifications and updates"

performance:
  caching: "Redis for session data, query results"
  database: "Connection pooling, query optimization"
  api: "Response compression, ETags, rate limiting"
  monitoring: "APM with OpenTelemetry, Prometheus metrics"

  detailed_optimization:
    database_optimization:
      connection_pooling:
        min: 5
        max: 20
        idle_timeout: 30s
      query_optimization:
        - Use prepared statements
        - Implement query result caching
        - Database query monitoring
      indexing:
        - Primary keys on all tables
        - Foreign key indexes
        - Composite indexes for common queries

    rate_limiting:
      global: 1000 requests/minute per IP
      authenticated: 5000 requests/minute per user
      api_key: 10000 requests/minute per key
      specific_endpoints:
        login: 5 attempts/minute per IP
        password_reset: 3 attempts/hour per email

environments:
  development:
    database:
      host: localhost
      port: 5432
      ssl: false
    redis:
      host: localhost
      port: 6379
    logging:
      level: debug
      format: pretty

  staging:
    database:
      host: staging-db.internal
      port: 5432
      ssl: true
      connection_pool: 10
    redis:
      host: staging-redis.internal
      port: 6379
      cluster: false
    logging:
      level: info
      format: json

  production:
    database:
      host: prod-db-cluster.internal
      port: 5432
      ssl: true
      connection_pool: 20
      read_replicas: 2
    redis:
      cluster: true
      nodes: 3
    logging:
      level: warn
      format: json
      external: true # Send to ELK stack

core_features:
  - name: Authentication (auth)
    capabilities:
      - JWT Authentication
      - API Key Authentication
      - Flexible Authentication (JWT + API Key)
      - Role-based Access Control (RBAC)
      - Permission-based Access Control
      - Multi-factor Authentication (MFA)
      - Session Management
      - Password Policy Enforcement

  - name: User Management (user)
    capabilities:
      - User Registration
      - User Profile Management
      - User Settings
      - User Preferences
      - User Activity Tracking
      - Email Verification
      - Account Activation/Deactivation
      - User Search and Filtering

  - name: RBAC
    capabilities:
      - Role Management
      - Permission Management
      - Role Assignment
      - Permission Assignment
      - User-Role Mapping
      - Role-Permission Mapping
      - Role Hierarchy
      - Dynamic Permissions
      - Resource-Based Access Control

  - name: Event Bus System
    capabilities:
      - Event Publishing
      - Event Subscribing
      - Event Queue Management
      - Event Persistence
      - Event Analytics
      - Event Replay
      - Event Versioning
      - Dead Letter Queue

  - name: Audit System
    capabilities:
      - Activity Logging
      - Security Audit
      - User Action Tracking
      - System Event Logging
      - Audit Trail Management
      - Real-time Audit Alerts
      - Compliance Reporting
      - Data Retention Policies

  - name: Health Monitoring
    capabilities:
      - System Health Checks
      - Service Status Monitoring
      - Performance Metrics
      - Resource Usage Tracking
      - Error Rate Monitoring
      - Database Health Monitoring
      - Cache Health Monitoring
      - Custom Health Checks

  - name: Error Handling
    capabilities:
      - Custom Error Types
      - Error Logging
      - Error Reporting
      - Error Recovery
      - Error Analytics
      - Error Notification
      - Error Aggregation
      - Error Rate Limiting

  - name: Event Analytics
    capabilities:
      - Event Data Collection
      - Event Analysis
      - Usage Statistics
      - Performance Metrics
      - User Behavior Analysis
      - Real-time Dashboards
      - Custom Reports
      - Data Export

core_flows:
  authentication:
    flow: >
      Request -> Rate Limiting -> Auth Middleware -> JWT/API Key Validation -> 
      User Context -> RBAC Check -> Permission Check -> Response
  event:
    flow: >
      Event Trigger -> Event Validation -> Event Bus -> Event Queue -> 
      Event Handlers -> Event Analytics -> Audit Log -> Dead Letter Queue (if failed)
  rbac:
    flow: >
      Request -> User Context -> Role Resolution -> Permission Check -> 
      Resource Access Validation -> Cache Update -> Response
  audit:
    flow: >
      Action -> Audit Logger -> Event Bus -> Audit Storage -> 
      Real-time Alerts -> Audit Analytics -> Compliance Check

design_guidelines:
  - Separate core features into clear modules
  - Use interfaces between modules
  - Apply Dependency Injection
  - Implement comprehensive error handling
  - Use TypeScript strict mode
  - Follow SOLID principles
  - Implement proper logging and monitoring
  - Use database transactions for data consistency
  - Implement proper input validation and sanitization
  - Use environment-specific configurations
  - Implement proper testing strategies
  - Use code formatting and linting tools
  - Improve Event System:
      - Use Event Sourcing Pattern
      - Separate Event Store
      - Add Event Versioning
      - Implement Event Replay
  - Improve RBAC:
      - Add Role Hierarchy
      - Add Dynamic Permissions
      - Support Resource-Based Access
      - Implement Permission Caching
  - Improve Audit System:
      - Add Real-Time Audit
      - Add Audit Analytics
      - Add Compliance Reporting
      - Implement Data Retention
  - Improve Error Handling:
      - Add Error Recovery
      - Add Error Analytics
      - Add Error Notification
      - Implement Circuit Breaker Pattern
  - Add Monitoring & Analytics:
      - Real-Time Monitoring
      - Performance Analytics
      - Usage Analytics
      - Security Analytics

migration_strategy:
  database:
    tool: Knex.js migrations
    versioning: Sequential numbering
    rollback: Support for rollback scripts
    seeding: Initial data seeding scripts

  events:
    versioning: Semantic versioning for event schemas
    compatibility: Backward compatibility for 2 major versions
    migration: Event transformation scripts

  api:
    versioning: URL path versioning
    deprecation: 6 months deprecation period
    documentation: Migration guides for each version

ci_cd:
  pipeline: "GitHub Actions"
  stages: ["Test", "Build", "Security Scan", "Deploy"]
  testing: "Automated unit, integration, e2e tests"
  deployment: "Zero-downtime rolling deployments"
  rollback: "Automated rollback on deployment failures"
  environments: "Automated deployment to staging and production"

  detailed_pipeline:
    - Code checkout
    - Dependency installation
    - Linting and formatting check
    - Unit tests
    - Integration tests
    - Security scanning
    - Build application
    - Deploy to staging
    - E2E tests on staging
    - Deploy to production

  tools:
    ci: GitHub Actions / GitLab CI
    security: Snyk / OWASP dependency check
    quality: SonarQube
    deployment: Docker + Kubernetes

recommendations:
  - name: Move to Pure Domain-Driven Design (DDD)
    details:
      - Represent each module as a Bounded Context
      - Use aggregates, entities, and value objects
      - Prevent leakage of internal models
      - Implement domain events
      - Use ubiquitous language

  - name: Enforce Consistent Layered Architecture
    details:
      - Feature folder: controller, service, schema only
      - No business logic in controller
      - Services must not depend on transport layer
      - Use dependency injection containers
      - Implement proper error boundaries

  - name: Split Core into Internal Libraries
    details:
      - Extract reusable packages: RBAC, Auth, Audit, EventBus
      - Improve testing and cross-system reuse
      - Version internal libraries independently
      - Create shared type definitions

  - name: Introduce Module Registry
    details:
      - Auto-register modules with lifecycle hooks (onInit, onShutdown)
      - Enable scalable module loading
      - Implement health checks per module
      - Support hot module reloading in development

  - name: Event Store Design
    details:
      - Use event_store table or Redis/Kafka
      - Support replay, audit, and consistency
      - Implement event snapshots for performance
      - Add event schema validation

  - name: Plugin-First Architecture
    details:
      - Allow system extension with plugins
      - Expose system hooks: onAuth, onEventPublished
      - Implement plugin lifecycle management
      - Create plugin marketplace/registry

  - name: Extend CLI Tooling
    details:
      - CLI scaffolding for dev experience (e.g., `aegisx g module`)
      - Include format, test, lint built-in
      - Database migration commands
      - Development server with hot reload

  - name: Internal Developer Portal
    details:
      - Docs, API specs, audit, health dashboard
      - Improve observability and team collaboration
      - Real-time system metrics
      - Development workflow automation

nx_workspace:
  purpose: >
    Use Nx as a monorepo tool to organize the modular monolith project, improve
    developer productivity, and enable scalable code sharing and dependency management.

  benefits:
    - Incremental builds and testing with Nx caching
    - Explicit dependency graph visualization
    - Easy code sharing via libraries across modules/features
    - Consistent linting, formatting, and testing configuration
    - Built-in CLI tooling for generating modules, services, and controllers
    - Support for multiple runtimes (Node.js, frontend frameworks) if needed

  structure_recommendation:
    apps:
      - aegisx-api/ # The main Fastify API application
    libs:
      - auth/ # Auth module as a reusable library
      - user/ # User management library
      - rbac/ # RBAC logic and models
      - audit/ # Audit logging and tracking
      - event-bus/ # Event bus and event sourcing libs
      - shared/ # Shared utilities, types, constants
      - core/ # Core domain entities and interfaces
      - database/ # Database utilities and migrations
      - monitoring/ # Health checks and metrics
      - testing/ # Testing utilities and fixtures

  development_guidelines:
    - Enforce strict boundaries between libs using Nx tags and lint rules
    - Use Nx generators or custom schematics for creating new features/modules
    - Structure each domain lib with layered folders: controller, service, schema
    - Avoid direct cross-imports that break module boundaries
    - Use Dependency Injection and interfaces to decouple implementations
    - Utilize Nx affected commands to optimize CI/CD pipeline builds and tests
    - Implement consistent code formatting with Prettier
    - Use ESLint with TypeScript rules
    - Implement pre-commit hooks for code quality

  build_and_deploy:
    - Build apps and libs separately for deployment
    - Consider using Nx Cloud for distributed caching and faster builds
    - Separate environment configurations per app for multi-stage deployments
    - Use Docker multi-stage builds for production
    - Implement proper secret management

  testing:
    - Use Vitest for unit tests in libs and apps
    - Create integration tests inside app folder or dedicated libs
    - Run lint and format checks via Nx targets
    - Implement test coverage reporting
    - Use Nx affected for running only changed tests

docker:
  development:
    services:
      - postgres: PostgreSQL 14
      - redis: Redis 7
      - rabbitmq: RabbitMQ 3-management
      - elasticsearch: Elasticsearch 8 (optional)

  production:
    multi_stage_build: true
    base_image: node:22-alpine
    security:
      - Run as non-root user
      - Use distroless images when possible
      - Scan for vulnerabilities

  compose:
    version: "3.8"
    networks: Custom bridge network
    volumes: Named volumes for data persistence

build_system:
  compiler:
    primary: SWC
    benefits:
      - "20x faster than TypeScript compiler"
      - "Zero configuration for most TypeScript projects"
      - "Smaller bundle size with better optimizations"
      - "Same output - fully compatible"
      - "Better DX - faster feedback loop"
    note: "SWC only transpiles code, TypeScript runs separately for type checking"

  scripts:
    development:
      - "npm run dev - Start development server with ts-node-dev"
      - "npm run test:watch - Run tests in watch mode"

    production:
      - "npm run build - Compile TypeScript to JavaScript using SWC"
      - "npm run type-check - Run TypeScript type checking only"
      - "npm run check - Run full code quality checks (lint + type-check + build)"
      - "npm run start - Run production server"

    testing:
      - "npm run test - Run all tests"
      - "npm run test:coverage - Run tests with coverage report"
      - "npm run test:watch - Run tests in watch mode"

    quality:
      - "npm run lint - ESLint for code linting"
      - "npm run format - Format code with Prettier"
      - "npm run commit - Interactive commit with commitizen"

    release:
      - "npm run release:dry - Test release locally (dry run)"

git_workflow:
  commit_convention: Conventional Commits
  tools:
    - Husky for git hooks
    - Commitizen for interactive commits
    - Commitlint for commit message validation
    - Semantic Release for automated versioning

  commit_types:
    feat: "New features → Minor version bump"
    fix: "Bug fixes → Patch version bump"
    perf: "Performance improvements → Patch version bump"
    docs: "Documentation updates"
    style: "Code style changes"
    refactor: "Code refactoring → Patch version bump"
    test: "Adding tests"
    chore: "Maintenance tasks"
    build: "Build system changes"
    ci: "CI/CD changes"
    breaking_change: "Add BREAKING CHANGE: in commit body → Major version bump"

  pre_commit_hooks:
    - ESLint for code linting
    - TypeScript type checking
    - Prettier formatting

  automated_releases:
    main: "Automatic release to production"
    beta: "Beta pre-release"
    alpha: "Alpha pre-release"
    dry_run: "npm run release:dry"

project_structure:
  detailed:
    src:
      core:
        - "auth/ - Authentication system with JWT and API keys"
        - "user/ - User management with CRUD operations"
        - "rbac/ - Role-based access control system"
        - "audit/ - Comprehensive audit logging"
        - "api-key/ - API key management system"
      features:
        - "Feature modules for specific business logic"
      config:
        - "Environment configuration and validation"
      database:
        - "Knex.js migrations and seeds"
        - "Database connection and pooling"
      shared:
        - "Shared utilities and common functions"
        - "Type definitions and interfaces"
        - "Constants and enums"

    root_files:
      configuration:
        - ".env.example - Environment variables template"
        - ".nvmrc - Node.js version specification"
        - ".commitlintrc.json - Commit message linting"
        - ".eslintrc.json - ESLint configuration"
        - ".prettierignore - Prettier ignore patterns"
        - "tsconfig.json - TypeScript configuration"

      docker:
        - "Dockerfile - Production container setup"
        - "docker-compose.yml - Development environment"
        - ".dockerignore - Docker build exclusions"

      ci_cd:
        - ".github/workflows/ - GitHub Actions CI/CD"
        - ".husky/ - Git hooks configuration"

      documentation:
        - "docs/ - Comprehensive documentation"
        - "README.md - Project overview and setup"

deployment:
  containerization: "Docker with multi-stage builds"
  orchestration: "Kubernetes with separate services"
  environments: ["Development", "Staging", "Production"]
  scaling: "Horizontal scaling with load balancers"
  monitoring: "Health checks, metrics, distributed tracing"
  blue_green: "Zero-downtime deployment strategies"

  docker:
    development:
      compose_services:
        - "PostgreSQL database"
        - "Redis cache"
        - "RabbitMQ message broker"
        - "Application server"
      command: "docker-compose up -d"

    production:
      dockerfile: "Multi-stage build for optimization"
      base_image: "node:22-alpine"
      build_command: "docker build -t aegisx-api ."
      security:
        - "Non-root user execution"
        - "Minimal attack surface"
        - "Security scanning integration"

  environment_checklist:
    security:
      - "Set strong JWT_SECRET and JWT_REFRESH_SECRET"
      - "Configure production database with SSL"
      - "Setup Redis cluster for high availability"
      - "Configure RabbitMQ cluster with proper queues"
      - "Review and rotate API keys regularly"
      - "Setup proper CORS origins"
      - "Configure rate limiting based on usage"
      - "Setup SSL/TLS certificates"

    performance:
      - "Database connection pooling tuning"
      - "Redis memory optimization and persistence"
      - "RabbitMQ queue management and monitoring"
      - "Enable gzip compression"
      - "Setup CDN for static assets"

    monitoring:
      - "Setup Docker health checks"
      - "Configure Docker logs collection"
      - "Setup health check endpoints"
      - "Configure alerting systems"

features_implemented:
  authentication:
    jwt_system:
      - "Access tokens (15 minutes expiry)"
      - "Refresh tokens (7 days expiry)"
      - "Token blacklisting on logout"
      - "Automatic token refresh"

    api_key_system:
      - "API key generation and management"
      - "Rate limiting per API key"
      - "API key rotation capabilities"

    security_features:
      - "Password hashing with bcrypt"
      - "Account lockout after failed attempts"
      - "IP tracking and logging"
      - "Session management"

  user_management:
    crud_operations:
      - "User registration with validation"
      - "User profile management"
      - "User search and filtering"
      - "Account activation/deactivation"

    validation:
      - "Email format validation"
      - "Password strength requirements"
      - "Input sanitization"
      - "TypeBox schema validation"

  rbac_system:
    role_management:
      - "Dynamic role creation"
      - "Role hierarchy support"
      - "Role assignment to users"
      - "System vs custom roles"

    permission_system:
      - "Granular permission control"
      - "Resource-based permissions"
      - "Permission inheritance"
      - "Dynamic permission checking"

  audit_system:
    logging_capabilities:
      - "User action tracking"
      - "API endpoint access logging"
      - "Data change tracking (before/after)"
      - "IP address and user agent logging"
      - "Timestamp and user context"

    analytics:
      - "User activity reports"
      - "API usage statistics"
      - "Security event monitoring"
      - "Performance metrics"

  event_system:
    rabbitmq_integration:
      - "Event publishing and subscribing"
      - "Queue management"
      - "Dead letter queue handling"
      - "Event persistence"
      - "Event replay capabilities"

    event_types:
      - "User events (login, logout, registration)"
      - "System events (errors, performance)"
      - "Business events (custom domain events)"
      - "Audit events (data changes)"

testing_implementation:
  coverage_targets:
    configuration: "Environment validation and config loading"
    authentication: "JWT tokens, login/logout, middleware"
    user_management: "CRUD operations and validation"
    api_endpoints: "Request/response validation"
    event_system: "RabbitMQ integration and event publishing"
    database_operations: "Repository patterns and queries"

  test_structure:
    unit_tests: "src/**/__tests__/ - Co-located with source code"
    integration_tests: "Database and external service integration"
    e2e_tests: "Full application workflow testing"

  ci_integration:
    github_actions:
      - "Automated testing on PR and push"
      - "Node.js versions 22 testing"
      - "Coverage report generation"
      - "Security vulnerability scanning"

  testing_tools:
    framework: "Vitest for TypeScript"
    mocking: "vi.mock() for external dependencies"
    database: "Testcontainers for PostgreSQL testing"
    api_testing: "Supertest for HTTP endpoint testing"
    coverage: "Built-in Vitest coverage reporting"

documentation_system:
  api_documentation:
    swagger: "OpenAPI 3.0 specification"
    interactive: "Swagger UI for API exploration"
    postman: "Postman collection export"

  guides:
    getting_started:
      - "Docker Compose Development Guide"
      - "Development Workflow"
      - "Environment Setup"

    architecture:
      - "Event-Driven Architecture Overview"
      - "Event Bus Documentation"
      - "Audit Logging System"

    authentication:
      - "Auth Enhancement Summary"
      - "Auth Routes Testing Guide"
      - "JWT Implementation Details"

    deployment:
      - "Docker Deployment Guide"
      - "Production Environment Setup"
      - "Security Configuration"

    analytics:
      - "Event Analytics System"
      - "Monitoring and Metrics"
      - "Performance Optimization"

release_management:
  semantic_versioning:
    current_version: "v2.23.1"
    total_releases: 48
    automation: "Semantic Release with GitHub Actions"

  release_channels:
    production: "main branch → automatic production release"
    staging: "beta branch → beta pre-release"
    development: "alpha branch → alpha pre-release"

  changelog:
    automated: "Generated from conventional commits"
    format: "Keep a Changelog format"
    sections:
      - "Added - New features"
      - "Changed - Changes in existing functionality"
      - "Deprecated - Soon-to-be removed features"
      - "Removed - Removed features"
      - "Fixed - Bug fixes"
      - "Security - Security improvements"

monitoring_analytics:
  real_time_tracking:
    user_activities:
      - "Login/logout events"
      - "API endpoint usage"
      - "Feature usage patterns"
      - "Error rate monitoring"

    system_metrics:
      - "Response time monitoring"
      - "Database query performance"
      - "Memory and CPU usage"
      - "Cache hit/miss ratios"

  audit_analytics:
    compliance_reporting:
      - "User access reports"
      - "Data modification tracking"
      - "Security event logging"
      - "Regulatory compliance data"

    business_intelligence:
      - "User behavior analysis"
      - "API usage trends"
      - "Performance bottleneck identification"
      - "Resource utilization optimization"

compliance_security:
  data_protection: "GDPR compliance with data portability"
  encryption: "Data at rest and in transit encryption"
  audit_trail: "Complete audit logging for compliance"
  backup_recovery: "Automated backup and disaster recovery"
  penetration_testing: "Regular security assessments"

frontend_integration:
  api_contract: "RESTful endpoints + WebSocket for real-time"
  authentication: "JWT Bearer tokens"
  cors: "Configured for development and production origins"
  documentation: "OpenAPI spec for SDK generation"
  error_handling: "Standardized error response format"
  sdk_generation: "Auto-generated TypeScript SDK"

frontend_responsibility_separation:
  api_backend_responsibilities:
    - "Data validation and sanitization"
    - "Business logic implementation"
    - "Database operations and transactions"
    - "Authentication and authorization"
    - "Rate limiting and security"
    - "Audit logging and monitoring"
    - "Background job processing"
    - "External API integrations"

  frontend_application_responsibilities:
    - "User interface and user experience"
    - "Client-side routing and navigation"
    - "State management (Redux, Zustand, etc.)"
    - "Form validation (client-side)"
    - "Caching strategies (React Query, SWR)"
    - "Component architecture and design system"
    - "Build optimization and bundling"
    - "Browser compatibility and polyfills"

deployment_architecture:
  api_deployment:
    environment: "Containerized with Docker/Kubernetes"
    scaling: "Horizontal scaling based on API load"
    monitoring: "API-specific metrics and logging"
    health_checks: "API health endpoints"

  frontend_deployment:
    note: "Frontend apps deployed separately through Nx workspace"
    separation_benefits:
      - "Independent deployment cycles"
      - "Technology stack flexibility"
      - "Team autonomy"
      - "Scalability per application needs"
      - "Different caching strategies"

multi_tenant_architecture:
  core_api_role:
    purpose: "Central Identity & Access Management Hub for multiple applications"
    responsibilities:
      - "Single Sign-On (SSO) for all connected applications"
      - "Centralized user management and profile services"
      - "Role-Based Access Control (RBAC) engine"
      - "Permission management across applications"
      - "Tenant/Organization management"
      - "API gateway and service discovery"
      - "Centralized audit logging and compliance"

  tenant_isolation:
    database_strategy: "Schema-per-tenant with shared infrastructure"
    data_partitioning:
      - "Tenant-specific data isolation"
      - "Shared reference data (roles, permissions)"
      - "Cross-tenant analytics with data anonymization"
    security_boundaries:
      - "Tenant-specific encryption keys"
      - "Network isolation per tenant"
      - "Rate limiting per tenant"

  application_registration:
    app_onboarding:
      - "Application registration in Core API"
      - "OAuth 2.0 client credentials generation"
      - "Scope and permission mapping"
      - "Callback URL configuration"
    service_discovery:
      - "Dynamic service registration"
      - "Health check monitoring"
      - "Load balancing configuration"
      - "Circuit breaker patterns"

  cross_app_integration:
    sso_implementation:
      flow: "Authorization Code with PKCE"
      tokens: "JWT access tokens + refresh tokens"
      session_management: "Centralized session store in Redis"
      logout: "Single logout across all applications"

    user_profile_federation:
      standard_claims:
        ["sub", "email", "name", "roles", "permissions", "tenant"]
      custom_claims: "Application-specific user attributes"
      profile_sync: "Real-time profile updates across apps"

    permission_propagation:
      pattern: "Event-driven permission updates"
      implementation:
        - "Core API publishes permission change events"
        - "Applications subscribe to relevant permission events"
        - "Cache invalidation on permission changes"
        - "Graceful degradation on Core API unavailability"

application_architecture_patterns:
  microservice_communication:
    service_mesh: "Istio for service-to-service communication"
    api_gateway: "Kong/Envoy for external traffic"
    message_broker: "RabbitMQ for async communication"
    event_streaming: "Apache Kafka for real-time events"

  frontend_integration:
    authentication_sdk:
      implementation: "TypeScript SDK for all frontend frameworks"
      features:
        - "Automatic token refresh"
        - "Session management"
        - "Permission-based UI rendering"
        - "Multi-tenant context switching"

    state_management:
      pattern: "Federated state with Core API as source of truth"
      implementation:
        - "User state managed by Core API"
        - "Application state managed locally"
        - "Real-time state sync via WebSocket"

  backend_integration:
    middleware_pattern:
      authentication: "JWT validation middleware"
      authorization: "RBAC enforcement middleware"
      tenant_context: "Automatic tenant resolution"
      audit_logging: "Request/response audit trails"

    database_strategy:
      primary_data: "Application-specific databases"
      user_data: "Centralized in Core API"
      shared_data: "Reference data from Core API"
      caching: "Distributed cache with Redis"

deployment_strategy:
  core_api_deployment:
    high_availability: "Multi-region deployment with failover"
    scaling: "Horizontal scaling with load balancing"
    monitoring: "Comprehensive health checks and metrics"
    backup: "Automated backup and disaster recovery"

  application_deployment:
    independence: "Each application deployed independently"
    environment_parity: "Consistent environments across apps"
    blue_green: "Zero-downtime deployments"
    feature_flags: "Gradual rollout capabilities"

  infrastructure_requirements:
    kubernetes_cluster: "Shared cluster with namespace isolation"
    service_mesh: "Cross-service communication and security"
    observability: "Centralized logging and monitoring"
    secrets_management: "HashiCorp Vault for credentials"

security_architecture:
  zero_trust_model:
    implementation: "Never trust, always verify"
    principles:
      - "Identity verification for every request"
      - "Least privilege access control"
      - "Continuous security monitoring"
      - "Encrypted communication everywhere"

  api_security:
    authentication: "OAuth 2.0 + OpenID Connect"
    authorization: "Fine-grained RBAC/ABAC"
    rate_limiting: "Per-user and per-application limits"
    input_validation: "Schema-based validation at gateway"

  data_protection:
    encryption_at_rest: "AES-256 encryption for all databases"
    encryption_in_transit: "TLS 1.3 for all communications"
    key_management: "Hardware Security Modules (HSM)"
    data_masking: "PII protection in non-prod environments"

governance_compliance:
  api_governance:
    standards: "OpenAPI 3.0 specifications for all APIs"
    versioning: "Semantic versioning with backward compatibility"
    lifecycle_management: "API deprecation and sunset policies"
    documentation: "Automated API documentation generation"

  compliance_framework:
    gdpr_compliance: "Data portability and right to be forgotten"
    audit_requirements: "Comprehensive audit trails"
    data_retention: "Configurable retention policies"
    privacy_controls: "Consent management and privacy settings"

  monitoring_governance:
    sla_monitoring: "Service Level Agreement tracking"
    performance_baselines: "Application performance standards"
    error_budgets: "Error rate and latency targets"
    incident_management: "Automated incident response workflows"

implementation_notes:
  ai_instruction_purpose: >
    This document serves as comprehensive architectural guidance for AI code generation.
    All features listed should be implemented following the specified patterns and principles.
    Focus on implementing complete, production-ready solutions that maintain architectural consistency.

  key_principles:
    - "Follow TypeScript strict mode and type safety"
    - "Implement proper error handling with standardized responses"
    - "Use dependency injection for testability and modularity"
    - "Apply event-driven patterns for loose coupling"
    - "Maintain clear separation of concerns across all layers"
    - "Write comprehensive tests for all functionality"
    - "Document all APIs with OpenAPI specifications"
    - "Ensure security best practices in all implementations"
    - "Design for scalability and performance from the start"

flexible_multi_tenant_design:
  configuration_driven:
    enable_multi_tenant: "Environment variable ENABLE_MULTI_TENANT=true/false"
    default_mode: "Single-tenant (ENABLE_MULTI_TENANT=false)"
    migration_path: "Can enable multi-tenancy later without breaking changes"

  single_tenant_mode:
    description: "Default mode for simple applications"
    database_strategy: "No tenant_id columns, simplified schema"
    user_experience: "No tenant selection, direct login"
    admin_complexity: "Minimal - just user/role management"

    schema_differences:
      users_table: "No tenant_id field required"
      roles_table: "Global roles only"
      permissions_table: "Global permissions only"
      sessions_table: "Simple user sessions"

    api_endpoints:
      - "POST /auth/login (simple login)"
      - "GET /auth/me (user profile)"
      - "GET /users (all users)"
      - "POST /roles (global roles)"

  multi_tenant_mode:
    description: "Enterprise mode for multiple organizations"
    database_strategy: "Tenant_id columns + data isolation"
    user_experience: "Tenant selection + context switching"
    admin_complexity: "Full tenant management required"

    schema_differences:
      users_table: "Include tenant_id field"
      roles_table: "Tenant-specific or global roles"
      permissions_table: "Tenant-scoped permissions"
      user_tenants_table: "Many-to-many user-tenant mapping"

    api_endpoints:
      - "GET /tenants (user's tenants)"
      - "POST /auth/switch-tenant"
      - "GET /users?tenant_id=xxx"
      - "POST /tenants (create new tenant)"

  migration_strategy:
    single_to_multi_tenant:
      step_1: "Add tenant_id columns with DEFAULT value"
      step_2: "Create default tenant for existing data"
      step_3: "Update API to handle tenant context"
      step_4: "Enable ENABLE_MULTI_TENANT=true"
      step_5: "Add tenant management UI"

    database_migration_example: |
      -- Migration: Add multi-tenant support
      ALTER TABLE users ADD COLUMN tenant_id UUID DEFAULT '00000000-0000-0000-0000-000000000001';
      ALTER TABLE roles ADD COLUMN tenant_id UUID DEFAULT '00000000-0000-0000-0000-000000000001';

      -- Create default tenant
      INSERT INTO tenants (id, name, subdomain) 
      VALUES ('00000000-0000-0000-0000-000000000001', 'Default Organization', 'default');

    backward_compatibility: "Single-tenant apps continue working unchanged"

  implementation_approach:
    conditional_middleware:
      tenant_context: "Only active when ENABLE_MULTI_TENANT=true"
      tenant_validation: "Skip validation in single-tenant mode"
      tenant_isolation: "No isolation needed in single-tenant"

    database_queries:
      single_tenant: "SELECT * FROM users WHERE id = ?"
      multi_tenant: "SELECT * FROM users WHERE id = ? AND tenant_id = ?"

    api_responses:
      single_tenant: |
        {
          "user": {
            "id": "uuid",
            "email": "user@example.com",
            "roles": ["admin"]
          }
        }
      multi_tenant: |
        {
          "user": {
            "id": "uuid", 
            "email": "user@example.com",
            "roles": ["admin"],
            "tenant": {
              "id": "tenant-uuid",
              "name": "Acme Corp"
            }
          }
        }

  configuration_examples:
    single_tenant_env: |
      # .env for single-tenant mode
      ENABLE_MULTI_TENANT=false
      DEFAULT_TENANT_ID=00000000-0000-0000-0000-000000000001

    multi_tenant_env: |
      # .env for multi-tenant mode  
      ENABLE_MULTI_TENANT=true
      REQUIRE_TENANT_SELECTION=true
      MAX_TENANTS_PER_USER=5

  code_examples:
    conditional_schema: |
      // User model with conditional tenant
      interface User {
        id: string;
        email: string;
        ...(config.ENABLE_MULTI_TENANT && { tenantId: string });
      }

    conditional_middleware: |
      // Middleware that adapts to mode
      export const tenantMiddleware = (req, res, next) => {
        if (config.ENABLE_MULTI_TENANT) {
          // Extract and validate tenant context
          req.tenantId = extractTenantFromRequest(req);
        } else {
          // Use default tenant or skip
          req.tenantId = config.DEFAULT_TENANT_ID;
        }
        next();
      };

    conditional_queries: |
      // Repository with mode-aware queries
      async findUsers(filters: UserFilters) {
        let query = 'SELECT * FROM users WHERE 1=1';
        const params = [];
        
        if (config.ENABLE_MULTI_TENANT && filters.tenantId) {
          query += ' AND tenant_id = ?';
          params.push(filters.tenantId);
        }
        
        return db.query(query, params);
      }

  benefits_of_flexible_approach:
    start_simple: "Begin with single-tenant, scale to multi-tenant"
    no_overhead: "Zero multi-tenant complexity when not needed"
    future_proof: "Can enable multi-tenancy without rewrite"
    gradual_migration: "Smooth transition path"
    cost_effective: "Pay complexity cost only when needed"

  use_case_recommendations:
    single_tenant_for:
      - "Personal projects"
      - "Small teams (< 50 users)"
      - "Simple applications"
      - "MVP/prototype phase"

    multi_tenant_for:
      - "SaaS applications"
      - "Enterprise customers"
      - "Multiple organizations"
      - "B2B platforms"
