{
  "version": 3,
  "sources": ["../../../../../../../packages/core/src/auth/PasswordService.ts"],
  "sourcesContent": ["/**\n * Password Service\n * \n * High-level password management service\n */\n\nimport {\n    hashPassword,\n    comparePassword,\n    validatePassword,\n    generateRandomPassword,\n    isPasswordCompromised,\n    type PasswordPolicy,\n    defaultPasswordPolicy\n} from '../utils/password';\n\n/**\n * Password Service Class\n */\nexport class PasswordService {\n    private policy: PasswordPolicy;\n\n    constructor(policy: PasswordPolicy = defaultPasswordPolicy) {\n        this.policy = policy;\n    }\n\n    /**\n     * Hash a password\n     */\n    async hash(password: string): Promise<string> {\n        // Validate password before hashing\n        const validation = this.validate(password);\n        if (!validation.isValid) {\n            throw new Error(`Password validation failed: ${validation.errors.join(', ')}`);\n        }\n\n        // Check if password is compromised (if enabled)\n        if (await isPasswordCompromised(password)) {\n            throw new Error('Password has been found in data breaches. Please choose a different password.');\n        }\n\n        return await hashPassword(password);\n    }\n\n    /**\n     * Compare password with hash\n     */\n    async compare(password: string, hashedPassword: string): Promise<boolean> {\n        return await comparePassword(password, hashedPassword);\n    }\n\n    /**\n     * Validate password against policy\n     */\n    validate(password: string): { isValid: boolean; errors: string[] } {\n        return validatePassword(password, this.policy);\n    }\n\n    /**\n     * Generate a random password\n     */\n    generate(length: number = 12): string {\n        return generateRandomPassword(length);\n    }\n\n    /**\n     * Update password policy\n     */\n    updatePolicy(newPolicy: Partial<PasswordPolicy>): void {\n        this.policy = { ...this.policy, ...newPolicy };\n    }\n\n    /**\n     * Get current password policy\n     */\n    getPolicy(): PasswordPolicy {\n        return { ...this.policy };\n    }\n\n    /**\n     * Check if password needs to be rehashed (for bcrypt cost updates)\n     */\n    needsRehash(hashedPassword: string): boolean {\n        // Simple check - if the hash doesn't start with expected bcrypt format\n        // In production, you might want to check the cost factor\n        return !hashedPassword.startsWith('$2b$12$');\n    }\n} "],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,sBAQO;AAKA,MAAM,gBAAgB;AAAA,EACjB;AAAA,EAER,YAAY,SAAyB,uCAAuB;AACxD,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,UAAmC;AAE1C,UAAM,aAAa,KAAK,SAAS,QAAQ;AACzC,QAAI,CAAC,WAAW,SAAS;AACrB,YAAM,IAAI,MAAM,+BAA+B,WAAW,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,IACjF;AAGA,QAAI,UAAM,uCAAsB,QAAQ,GAAG;AACvC,YAAM,IAAI,MAAM,+EAA+E;AAAA,IACnG;AAEA,WAAO,UAAM,8BAAa,QAAQ;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,UAAkB,gBAA0C;AACtE,WAAO,UAAM,iCAAgB,UAAU,cAAc;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,UAA0D;AAC/D,eAAO,kCAAiB,UAAU,KAAK,MAAM;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,SAAiB,IAAY;AAClC,eAAO,wCAAuB,MAAM;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,WAA0C;AACnD,SAAK,SAAS,EAAE,GAAG,KAAK,QAAQ,GAAG,UAAU;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,YAA4B;AACxB,WAAO,EAAE,GAAG,KAAK,OAAO;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,gBAAiC;AAGzC,WAAO,CAAC,eAAe,WAAW,SAAS;AAAA,EAC/C;AACJ;",
  "names": []
}
