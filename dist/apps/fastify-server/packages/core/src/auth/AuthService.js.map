{
  "version": 3,
  "sources": ["../../../../../../../packages/core/src/auth/AuthService.ts"],
  "sourcesContent": ["/**\n * Authentication Service\n * \n * Main authentication service combining JWT + Session Management\n * Provides login, register, logout, and token refresh functionality\n */\n\nimport { UserModel } from '../database/models/UserModel';\nimport { JwtService } from './JwtService';\nimport { PasswordService } from './PasswordService';\nimport { SessionService } from './SessionService';\nimport type { LoginRequest, LoginResponse } from '../types/auth';\nimport type { User } from '../types/user';\nimport type { ID } from '../types/core';\nimport type { JwtConfig } from '../types/config';\nimport type { PasswordPolicy } from '../utils/password';\n\n/**\n * Registration request interface\n */\nexport interface RegisterRequest {\n    email: string;\n    password: string;\n    firstName: string;\n    lastName: string;\n}\n\n/**\n * Authentication Service Class\n */\nexport class AuthService {\n    private jwtService: JwtService;\n    private passwordService: PasswordService;\n    private sessionService: SessionService;\n\n    constructor(\n        jwtConfig: JwtConfig,\n        passwordPolicy?: PasswordPolicy,\n        fastify?: any\n    ) {\n        this.jwtService = new JwtService(fastify, jwtConfig);\n        this.passwordService = new PasswordService(passwordPolicy);\n        this.sessionService = new SessionService(jwtConfig, fastify);\n    }\n\n    /**\n     * Register a new user\n     */\n    async register(request: RegisterRequest): Promise<{\n        user: Omit<User, 'passwordHash'>;\n        message: string;\n    }> {\n        // Check if user already exists\n        const existingUser = await UserModel.findByEmail(request.email);\n        if (existingUser) {\n            throw new Error('User with this email already exists');\n        }\n\n        // Hash password\n        const passwordHash = await this.passwordService.hash(request.password);\n\n        // Create user\n        const user = await UserModel.create({\n            email: request.email,\n            firstName: request.firstName,\n            lastName: request.lastName,\n            passwordHash,\n            isActive: true\n        });\n\n        // Remove password hash from response\n        const { passwordHash: _, ...userWithoutPassword } = user;\n\n        return {\n            user: userWithoutPassword,\n            message: 'User registered successfully'\n        };\n    }\n\n    /**\n     * Login user\n     */\n    async login(\n        request: LoginRequest,\n        metadata?: {\n            deviceInfo?: string;\n            ipAddress?: string;\n            userAgent?: string;\n            location?: string;\n        }\n    ): Promise<LoginResponse & { session: { id: ID } }> {\n        // Find user by email\n        const user = await UserModel.findByEmail(request.email);\n        if (!user) {\n            throw new Error('Invalid email or password');\n        }\n\n        // Check if user is active\n        if (!user.isActive) {\n            throw new Error('Account is deactivated');\n        }\n\n        // Verify password\n        const isPasswordValid = await this.passwordService.compare(\n            request.password,\n            user.passwordHash\n        );\n        if (!isPasswordValid) {\n            throw new Error('Invalid email or password');\n        }\n\n        // Generate tokens\n        const tokens = await this.jwtService.generateTokens({\n            userId: user.id,\n            email: user.email,\n            roles: [], // TODO: Add roles when RBAC is implemented\n            type: 'access'\n        });\n\n        // Create session\n        const session = await this.sessionService.createSession({\n            userId: user.id,\n            accessToken: tokens.accessToken,\n            refreshToken: tokens.refreshToken,\n            deviceInfo: metadata?.deviceInfo,\n            ipAddress: metadata?.ipAddress,\n            userAgent: metadata?.userAgent,\n            location: metadata?.location\n        });\n\n        // Update last login time\n        await UserModel.update(user.id, {\n            lastLoginAt: new Date()\n        });\n\n        // Remove password hash from response\n        const { passwordHash: _, ...userWithoutPassword } = user;\n\n        return {\n            user: userWithoutPassword,\n            accessToken: tokens.accessToken,\n            refreshToken: tokens.refreshToken,\n            session: {\n                id: session.id\n            }\n        };\n    }\n\n    /**\n     * Logout user\n     */\n    async logout(refreshToken: string): Promise<{ message: string }> {\n        const session = await this.sessionService.findSessionByToken(refreshToken);\n        if (session) {\n            await this.sessionService.terminateSession(session.id);\n        }\n\n        return {\n            message: 'Logged out successfully'\n        };\n    }\n\n    /**\n     * Refresh access token\n     */\n    async refreshToken(refreshToken: string): Promise<{\n        accessToken: string;\n        refreshToken: string;\n    } | null> {\n        const result = await this.sessionService.refreshSession(refreshToken);\n        if (!result) {\n            return null;\n        }\n\n        return {\n            accessToken: result.accessToken,\n            refreshToken: result.refreshToken\n        };\n    }\n\n    /**\n     * Validate authentication\n     */\n    async validateAuth(accessToken: string, refreshToken?: string): Promise<{\n        isValid: boolean;\n        user?: Omit<User, 'passwordHash'>;\n        needsRefresh?: boolean;\n    }> {\n        const validation = await this.sessionService.validateSession(accessToken, refreshToken);\n\n        if (!validation.isValid) {\n            return { isValid: false };\n        }\n\n        let user: User | null = null;\n        if (validation.user) {\n            user = await UserModel.findById(validation.user.userId);\n            if (!user || !user.isActive) {\n                return { isValid: false };\n            }\n        }\n\n        const { passwordHash: _, ...userWithoutPassword } = user || {} as User;\n\n        return {\n            isValid: true,\n            user: user ? userWithoutPassword : undefined,\n            needsRefresh: validation.needsRefresh\n        };\n    }\n\n    /**\n     * Change password\n     */\n    async changePassword(\n        userId: ID,\n        currentPassword: string,\n        newPassword: string\n    ): Promise<{ message: string }> {\n        // Get user\n        const user = await UserModel.findById(userId);\n        if (!user) {\n            throw new Error('User not found');\n        }\n\n        // Verify current password\n        const isCurrentPasswordValid = await this.passwordService.compare(\n            currentPassword,\n            user.passwordHash\n        );\n        if (!isCurrentPasswordValid) {\n            throw new Error('Current password is incorrect');\n        }\n\n        // Hash new password\n        const newPasswordHash = await this.passwordService.hash(newPassword);\n\n        // Update user password\n        await UserModel.update(userId, {\n            passwordHash: newPasswordHash,\n            updatedAt: new Date()\n        });\n\n        // Terminate all other sessions (force re-login)\n        await this.sessionService.terminateAllUserSessions(userId);\n\n        return {\n            message: 'Password changed successfully'\n        };\n    }\n\n    /**\n     * Request password reset (placeholder)\n     */\n    async requestPasswordReset(email: string): Promise<{ message: string }> {\n        const user = await UserModel.findByEmail(email);\n        if (!user) {\n            // Don't reveal if email exists\n            return {\n                message: 'If the email exists, a password reset link has been sent'\n            };\n        }\n\n        // TODO: Generate reset token and send email\n        console.log(`Password reset requested for: ${email}`);\n\n        return {\n            message: 'If the email exists, a password reset link has been sent'\n        };\n    }\n\n    /**\n     * Reset password (placeholder)\n     */\n    async resetPassword(\n        resetToken: string,\n        newPassword: string\n    ): Promise<{ message: string }> {\n        // TODO: Verify reset token and update password\n        throw new Error('Password reset not implemented yet');\n    }\n\n    /**\n     * Get user profile\n     */\n    async getProfile(userId: ID): Promise<Omit<User, 'passwordHash'> | null> {\n        const user = await UserModel.findById(userId);\n        if (!user) {\n            return null;\n        }\n\n        const { passwordHash: _, ...userWithoutPassword } = user;\n        return userWithoutPassword;\n    }\n} "],
  "mappings": "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",
  "names": []
}
