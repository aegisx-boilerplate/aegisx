{
  "version": 3,
  "sources": ["../../../../../../../packages/core/src/auth/JwtService.ts"],
  "sourcesContent": ["/**\n * JWT Service\n * \n * Handles JWT token generation, validation, and refresh operations\n */\n\nimport jwt from 'jsonwebtoken';\nimport { FastifyInstance } from 'fastify';\nimport { JwtPayload } from '../types/auth';\nimport { ID } from '../types/core';\n\nexport interface JwtTokens {\n    accessToken: string;\n    refreshToken: string;\n}\n\nexport class JwtService {\n    private readonly jwtSecret: string;\n    private readonly jwtRefreshSecret: string;\n    private readonly expiresIn: string;\n    private readonly refreshExpiresIn: string;\n\n    constructor(\n        private readonly fastify: FastifyInstance,\n        config: {\n            secret: string;\n            refreshSecret?: string;\n            expiresIn?: string;\n            refreshExpiresIn?: string;\n        }\n    ) {\n        this.jwtSecret = config.secret;\n        this.jwtRefreshSecret = config.refreshSecret || config.secret;\n        this.expiresIn = config.expiresIn || '15m';\n        this.refreshExpiresIn = config.refreshExpiresIn || '7d';\n\n        // Register JWT plugin\n        this.fastify.register(require('@fastify/jwt'), {\n            secret: this.jwtSecret,\n        });\n    }\n\n    async generateTokens(payload: JwtPayload): Promise<JwtTokens> {\n        // Temporary implementation without fastify.jwt\n        // TODO: Implement proper JWT generation\n        const token = 'temp-token-' + Date.now();\n\n        return {\n            accessToken: token + '-access',\n            refreshToken: token + '-refresh',\n        };\n    }\n\n    async verifyToken(token: string, isRefreshToken = false): Promise<JwtPayload> {\n        try {\n            // Temporary implementation without fastify.jwt\n            // TODO: Implement proper JWT verification\n            if (token.includes('temp-token-')) {\n                return {\n                    userId: 'temp-user-id',\n                    email: 'temp@example.com',\n                    roles: ['user'],\n                    type: isRefreshToken ? 'refresh' : 'access'\n                };\n            }\n            throw new Error('Invalid token');\n        } catch (error) {\n            throw new Error('Invalid token');\n        }\n    }\n\n    async refreshTokens(refreshToken: string): Promise<JwtTokens> {\n        try {\n            const payload = await this.verifyToken(refreshToken, true);\n            return this.generateTokens(payload);\n        } catch (error) {\n            throw new Error('Invalid refresh token');\n        }\n    }\n\n    private parseExpiresIn(expiresIn: string): number {\n        const match = expiresIn.match(/^(\\d+)([smhd])$/);\n        if (!match) {\n            throw new Error('Invalid expiresIn format');\n        }\n\n        const [, value, unit] = match;\n        const numValue = parseInt(value, 10);\n\n        switch (unit) {\n            case 's':\n                return numValue;\n            case 'm':\n                return numValue * 60;\n            case 'h':\n                return numValue * 60 * 60;\n            case 'd':\n                return numValue * 60 * 60 * 24;\n            default:\n                throw new Error('Invalid time unit');\n        }\n    }\n\n    private base64UrlEncode(str: string): string {\n        return Buffer.from(str)\n            .toString('base64')\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=/g, '');\n    }\n\n    private base64UrlDecode(str: string): string {\n        str = str.replace(/-/g, '+').replace(/_/g, '/');\n        while (str.length % 4) {\n            str += '=';\n        }\n        return Buffer.from(str, 'base64').toString();\n    }\n\n    private createSignature(header: string, payload: string, secret: string): string {\n        const crypto = require('crypto');\n        const hmac = crypto.createHmac('sha256', secret);\n        hmac.update(`${header}.${payload}`);\n        return this.base64UrlEncode(hmac.digest('base64'));\n    }\n\n    /**\n     * Decode token without verification (for inspection)\n     */\n    decodeToken(token: string): any {\n        return jwt.decode(token);\n    }\n\n    /**\n     * Check if token is expired\n     */\n    isTokenExpired(token: string): boolean {\n        try {\n            const decoded = this.decodeToken(token);\n            if (!decoded || !decoded.exp) {\n                return true;\n            }\n\n            const currentTime = Math.floor(Date.now() / 1000);\n            return decoded.exp < currentTime;\n        } catch {\n            return true;\n        }\n    }\n\n    /**\n     * Get token expiration date\n     */\n    getTokenExpiration(token: string): Date | null {\n        try {\n            const decoded = this.decodeToken(token);\n            if (!decoded || !decoded.exp) {\n                return null;\n            }\n\n            return new Date(decoded.exp * 1000);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Extract user ID from token\n     */\n    getUserIdFromToken(token: string): ID | null {\n        try {\n            const decoded = this.decodeToken(token);\n            return decoded?.userId || null;\n        } catch {\n            return null;\n        }\n    }\n} "],
  "mappings": "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",
  "names": ["jwt"]
}
