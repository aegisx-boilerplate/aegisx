{
  "version": 3,
  "sources": ["../../../../../../../packages/core/src/auth/SessionService.ts"],
  "sourcesContent": ["/**\n * Session Service\n * \n * Manages user sessions for JWT + Session hybrid approach\n * Provides session tracking, multi-device support, and security controls\n */\n\nimport { SessionModel, type Session } from '../database/models/SessionModel';\nimport { JwtService } from './JwtService';\nimport type { ID } from '../types/core';\nimport type { JwtConfig } from '../types/config';\n\n/**\n * Extended session interface with additional metadata\n */\nexport interface ExtendedSession extends Session {\n    deviceInfo?: string;\n    ipAddress?: string;\n    userAgent?: string;\n    location?: string;\n    isActive: boolean;\n}\n\n/**\n * Session creation data\n */\nexport interface CreateSessionData {\n    userId: ID;\n    accessToken: string;\n    refreshToken: string;\n    deviceInfo?: string;\n    ipAddress?: string;\n    userAgent?: string;\n    location?: string;\n    expiresAt?: Date;\n}\n\n/**\n * Session Service Class\n */\nexport class SessionService {\n    private jwtService: JwtService;\n\n    constructor(jwtConfig: JwtConfig, fastify?: any) {\n        this.jwtService = new JwtService(fastify, jwtConfig);\n    }\n\n    /**\n     * Create a new session\n     */\n    async createSession(data: CreateSessionData): Promise<ExtendedSession> {\n        // Calculate expiration time (default 7 days for refresh token)\n        const expiresAt = data.expiresAt || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n\n        const session = await SessionModel.create({\n            userId: data.userId,\n            token: data.refreshToken,\n            expiresAt\n        });\n\n        return {\n            ...session,\n            deviceInfo: data.deviceInfo,\n            ipAddress: data.ipAddress,\n            userAgent: data.userAgent,\n            location: data.location,\n            isActive: true\n        };\n    }\n\n    /**\n     * Find session by refresh token\n     */\n    async findSessionByToken(refreshToken: string): Promise<ExtendedSession | null> {\n        const session = await SessionModel.findByToken(refreshToken);\n        if (!session) {\n            return null;\n        }\n\n        // Check if session is expired\n        const isExpired = new Date() > session.expiresAt;\n        if (isExpired) {\n            await this.terminateSession(session.id);\n            return null;\n        }\n\n        return {\n            ...session,\n            isActive: true\n        };\n    }\n\n    /**\n     * Validate session and access token\n     */\n    async validateSession(accessToken: string, refreshToken?: string): Promise<{\n        isValid: boolean;\n        session?: ExtendedSession;\n        user?: { userId: ID; email: string; roles: string[] };\n        needsRefresh?: boolean;\n    }> {\n        try {\n            // First, try to validate access token\n            const tokenPayload = await this.jwtService.verifyToken(accessToken, false);\n\n            // If refresh token is provided, validate session\n            if (refreshToken) {\n                const session = await this.findSessionByToken(refreshToken);\n                if (!session || session.userId !== tokenPayload.userId) {\n                    return { isValid: false };\n                }\n\n                return {\n                    isValid: true,\n                    session,\n                    user: {\n                        userId: tokenPayload.userId,\n                        email: tokenPayload.email,\n                        roles: tokenPayload.roles\n                    }\n                };\n            }\n\n            // Access token valid, no session check needed\n            return {\n                isValid: true,\n                user: {\n                    userId: tokenPayload.userId,\n                    email: tokenPayload.email,\n                    roles: tokenPayload.roles\n                }\n            };\n\n        } catch (error: any) {\n            // Access token expired or invalid\n            if (error.message.includes('expired') && refreshToken) {\n                // Try to refresh using refresh token\n                const session = await this.findSessionByToken(refreshToken);\n                if (session) {\n                    return {\n                        isValid: true,\n                        session,\n                        needsRefresh: true\n                    };\n                }\n            }\n\n            return { isValid: false };\n        }\n    }\n\n    /**\n     * Refresh session tokens\n     */\n    async refreshSession(refreshToken: string): Promise<{\n        accessToken: string;\n        refreshToken: string;\n        session: ExtendedSession;\n    } | null> {\n        const session = await this.findSessionByToken(refreshToken);\n        if (!session) {\n            return null;\n        }\n\n        try {\n            // Generate new token pair\n            const tokenPayload = await this.jwtService.verifyToken(refreshToken, true);\n            const newTokens = await this.jwtService.generateTokens({\n                userId: tokenPayload.userId,\n                email: tokenPayload.email,\n                roles: tokenPayload.roles,\n                type: 'access'\n            });\n\n            // Update session with new refresh token\n            const updatedSession = await SessionModel.update(session.id, {\n                token: newTokens.refreshToken,\n                updatedAt: new Date()\n            });\n\n            if (!updatedSession) {\n                return null;\n            }\n\n            return {\n                accessToken: newTokens.accessToken,\n                refreshToken: newTokens.refreshToken,\n                session: {\n                    ...updatedSession,\n                    isActive: true\n                }\n            };\n\n        } catch (error) {\n            // Refresh token invalid, terminate session\n            await this.terminateSession(session.id);\n            return null;\n        }\n    }\n\n    /**\n     * Terminate a specific session\n     */\n    async terminateSession(sessionId: ID): Promise<boolean> {\n        return await SessionModel.delete(sessionId);\n    }\n\n    /**\n     * Terminate all sessions for a user\n     */\n    async terminateAllUserSessions(userId: ID): Promise<void> {\n        // TODO: Implement when we have more advanced SessionModel methods\n        // For now, we'll need to implement this in SessionModel\n        console.log(`Terminating all sessions for user: ${userId}`);\n    }\n\n    /**\n     * Get all active sessions for a user\n     */\n    async getUserSessions(userId: ID): Promise<ExtendedSession[]> {\n        // TODO: Implement when we have more advanced SessionModel methods\n        // For now, return empty array\n        return [];\n    }\n\n    /**\n     * Terminate other sessions (keep current one)\n     */\n    async terminateOtherSessions(userId: ID, currentSessionId: ID): Promise<void> {\n        // TODO: Implement when we have more advanced SessionModel methods\n        console.log(`Terminating other sessions for user: ${userId}, keeping: ${currentSessionId}`);\n    }\n\n    /**\n     * Cleanup expired sessions (for cron job)\n     */\n    async cleanupExpiredSessions(): Promise<number> {\n        // TODO: Implement when we have more advanced SessionModel methods\n        console.log('Cleaning up expired sessions...');\n        return 0;\n    }\n\n    /**\n     * Check if session is valid\n     */\n    async isSessionValid(sessionId: ID): Promise<boolean> {\n        try {\n            const session = await SessionModel.findById?.(sessionId);\n            if (!session) {\n                return false;\n            }\n\n            return new Date() <= session.expiresAt;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Extend session expiration\n     */\n    async extendSession(sessionId: ID, extendBy: number = 7 * 24 * 60 * 60 * 1000): Promise<boolean> {\n        try {\n            const newExpiresAt = new Date(Date.now() + extendBy);\n            const updated = await SessionModel.update(sessionId, {\n                expiresAt: newExpiresAt,\n                updatedAt: new Date()\n            });\n\n            return !!updated;\n        } catch {\n            return false;\n        }\n    }\n} "],
  "mappings": "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",
  "names": []
}
