{
  "version": 3,
  "sources": ["../../../../../../../packages/core/src/utils/password.ts"],
  "sourcesContent": ["/**\n * Password Utilities\n * \n * Provides secure password hashing, validation, and policy enforcement\n */\n\nimport bcrypt from 'bcrypt';\n\n/**\n * Password policy configuration\n */\nexport interface PasswordPolicy {\n    minLength: number;\n    requireUppercase: boolean;\n    requireLowercase: boolean;\n    requireNumbers: boolean;\n    requireSpecialChars: boolean;\n    maxLength?: number;\n}\n\n/**\n * Default password policy\n */\nexport const defaultPasswordPolicy: PasswordPolicy = {\n    minLength: 8,\n    requireUppercase: true,\n    requireLowercase: true,\n    requireNumbers: true,\n    requireSpecialChars: false,\n    maxLength: 128\n};\n\n/**\n * Salt rounds for bcrypt (higher = more secure but slower)\n */\nexport const SALT_ROUNDS = 12;\n\n/**\n * Hash a password using bcrypt\n */\nexport async function hashPassword(password: string): Promise<string> {\n    return await bcrypt.hash(password, SALT_ROUNDS);\n}\n\n/**\n * Compare a plain password with a hashed password\n */\nexport async function comparePassword(password: string, hashedPassword: string): Promise<boolean> {\n    return await bcrypt.compare(password, hashedPassword);\n}\n\n/**\n * Validate password against policy\n */\nexport function validatePassword(password: string, policy: PasswordPolicy = defaultPasswordPolicy): {\n    isValid: boolean;\n    errors: string[];\n} {\n    const errors: string[] = [];\n\n    // Check minimum length\n    if (password.length < policy.minLength) {\n        errors.push(`Password must be at least ${policy.minLength} characters long`);\n    }\n\n    // Check maximum length\n    if (policy.maxLength && password.length > policy.maxLength) {\n        errors.push(`Password must not exceed ${policy.maxLength} characters`);\n    }\n\n    // Check uppercase requirement\n    if (policy.requireUppercase && !/[A-Z]/.test(password)) {\n        errors.push('Password must contain at least one uppercase letter');\n    }\n\n    // Check lowercase requirement\n    if (policy.requireLowercase && !/[a-z]/.test(password)) {\n        errors.push('Password must contain at least one lowercase letter');\n    }\n\n    // Check numbers requirement\n    if (policy.requireNumbers && !/\\d/.test(password)) {\n        errors.push('Password must contain at least one number');\n    }\n\n    // Check special characters requirement\n    if (policy.requireSpecialChars && !/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n        errors.push('Password must contain at least one special character');\n    }\n\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n\n/**\n * Generate a random password\n */\nexport function generateRandomPassword(length: number = 12): string {\n    const lowercase = 'abcdefghijklmnopqrstuvwxyz';\n    const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    const numbers = '0123456789';\n    const specialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?';\n\n    const allChars = lowercase + uppercase + numbers + specialChars;\n    let password = '';\n\n    // Ensure at least one character from each category\n    password += lowercase[Math.floor(Math.random() * lowercase.length)];\n    password += uppercase[Math.floor(Math.random() * uppercase.length)];\n    password += numbers[Math.floor(Math.random() * numbers.length)];\n    password += specialChars[Math.floor(Math.random() * specialChars.length)];\n\n    // Fill the rest randomly\n    for (let i = password.length; i < length; i++) {\n        password += allChars[Math.floor(Math.random() * allChars.length)];\n    }\n\n    // Shuffle the password\n    return password.split('').sort(() => Math.random() - 0.5).join('');\n}\n\n/**\n * Check if password has been compromised (placeholder for future implementation)\n */\nexport async function isPasswordCompromised(password: string): Promise<boolean> {\n    // TODO: Integrate with HaveIBeenPwned API or similar service\n    // For now, return false (not compromised)\n    return false;\n} "],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,oBAAmB;AAiBZ,MAAM,wBAAwC;AAAA,EACjD,WAAW;AAAA,EACX,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,gBAAgB;AAAA,EAChB,qBAAqB;AAAA,EACrB,WAAW;AACf;AAKO,MAAM,cAAc;AAK3B,eAAsB,aAAa,UAAmC;AAClE,SAAO,MAAM,cAAAA,QAAO,KAAK,UAAU,WAAW;AAClD;AAKA,eAAsB,gBAAgB,UAAkB,gBAA0C;AAC9F,SAAO,MAAM,cAAAA,QAAO,QAAQ,UAAU,cAAc;AACxD;AAKO,SAAS,iBAAiB,UAAkB,SAAyB,uBAG1E;AACE,QAAM,SAAmB,CAAC;AAG1B,MAAI,SAAS,SAAS,OAAO,WAAW;AACpC,WAAO,KAAK,6BAA6B,OAAO,SAAS,kBAAkB;AAAA,EAC/E;AAGA,MAAI,OAAO,aAAa,SAAS,SAAS,OAAO,WAAW;AACxD,WAAO,KAAK,4BAA4B,OAAO,SAAS,aAAa;AAAA,EACzE;AAGA,MAAI,OAAO,oBAAoB,CAAC,QAAQ,KAAK,QAAQ,GAAG;AACpD,WAAO,KAAK,qDAAqD;AAAA,EACrE;AAGA,MAAI,OAAO,oBAAoB,CAAC,QAAQ,KAAK,QAAQ,GAAG;AACpD,WAAO,KAAK,qDAAqD;AAAA,EACrE;AAGA,MAAI,OAAO,kBAAkB,CAAC,KAAK,KAAK,QAAQ,GAAG;AAC/C,WAAO,KAAK,2CAA2C;AAAA,EAC3D;AAGA,MAAI,OAAO,uBAAuB,CAAC,wCAAwC,KAAK,QAAQ,GAAG;AACvF,WAAO,KAAK,sDAAsD;AAAA,EACtE;AAEA,SAAO;AAAA,IACH,SAAS,OAAO,WAAW;AAAA,IAC3B;AAAA,EACJ;AACJ;AAKO,SAAS,uBAAuB,SAAiB,IAAY;AAChE,QAAM,YAAY;AAClB,QAAM,YAAY;AAClB,QAAM,UAAU;AAChB,QAAM,eAAe;AAErB,QAAM,WAAW,YAAY,YAAY,UAAU;AACnD,MAAI,WAAW;AAGf,cAAY,UAAU,KAAK,MAAM,KAAK,OAAO,IAAI,UAAU,MAAM,CAAC;AAClE,cAAY,UAAU,KAAK,MAAM,KAAK,OAAO,IAAI,UAAU,MAAM,CAAC;AAClE,cAAY,QAAQ,KAAK,MAAM,KAAK,OAAO,IAAI,QAAQ,MAAM,CAAC;AAC9D,cAAY,aAAa,KAAK,MAAM,KAAK,OAAO,IAAI,aAAa,MAAM,CAAC;AAGxE,WAAS,IAAI,SAAS,QAAQ,IAAI,QAAQ,KAAK;AAC3C,gBAAY,SAAS,KAAK,MAAM,KAAK,OAAO,IAAI,SAAS,MAAM,CAAC;AAAA,EACpE;AAGA,SAAO,SAAS,MAAM,EAAE,EAAE,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG,EAAE,KAAK,EAAE;AACrE;AAKA,eAAsB,sBAAsB,UAAoC;AAG5E,SAAO;AACX;",
  "names": ["bcrypt"]
}
